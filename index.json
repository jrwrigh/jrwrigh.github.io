
    
    
    
    
    
    
    
    
    
    
    
    
    
    [{"authors":["admin"],"categories":null,"content":"I’m a PhD student studying aerospace engineering at the University of Colorado Boulder. My research interests are in computational fluid dynamics, finite element methods, programming for HPC applications, and vehicle aerodynamics.\nI’m also interested in motorsports and disc golf.\n","date":-62135596800,"expirydate":-62135596800,"kind":"term","lang":"en","lastmod":1664720471,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://www.jameswright.xyz/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"I’m a PhD student studying aerospace engineering at the University of Colorado Boulder. My research interests are in computational fluid dynamics, finite element methods, programming for HPC applications, and vehicle aerodynamics.\nI’m also interested in motorsports and disc golf.","tags":null,"title":"James Wright","type":"authors"},{"authors":null,"categories":null,"content":"Projects I Maintain Projects I Contribute To ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680526421,"objectID":"3c42bb4157bf51d85ae7ffc4e1685909","permalink":"https://www.jameswright.xyz/projects/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/projects/","section":"","summary":"Projects I Maintain Projects I Contribute To ","tags":null,"title":"Projects","type":"page"},{"authors":null,"categories":null,"content":" Table of Contents Programming/Computer Science Mathematics Here are various websites, papers, blog posts, and textbooks that I often recommend to people, or find really useful in general.\nProgramming/Computer Science Learn Git Branching Interactive website with great visualizations that teaches how to use git and, most importantly, what the commands are actually doing. I recommend this website to anyone who is wanting to get a “proper” understanding of how to use git, or even for general beginners who might not necessarily know the basic commands yet. If you’ve mastered the basic commands of git (pull, add, commit, push), this is a great next step.\nGit Cheatsheet Interactive cheatsheet that visualizes how to move changes from the 5 different levels of git, along with descriptions of what each command does.\nRookie HPC Documentation and tools for the MPI and OpenMP standards. It’s hard to find clear, well organized documentation for these backbones of the HPC world, and this one is fantastic.\nDifferentiable Programming from Scratch An introduction to automatic differentiation. It was an honorable mention in 3Blue1Brown’s Summer of Math Exposition 2.\nMathematics Keith Conrad’s Mathematical Expositions Fantastic small papers going over the fundamentals of a math subject. They’re well written, and don’t bite off more than necessary. I particularly enjoy his exposition on metric spaces.\nAn Introduction to the Conjugate Gradient Method Without the Agonizing Pain Does what it says on the tin. Gives an intuitive overview of the Conjugate Gradient method, while also giving intuition to other important concepts along the way, such as condition number, eigenvalues/vectors, and preconditioning.\nLinear Algebra Done Right The best textbook on understanding linear algebra on a fundamental level. The proofs throughout the book focus on intuition (by having the determinant “banished to the end of the book”, in Axler’s words). My personal favorite part is the fact that it makes firm connections between continuous linear algebra and “matrix” algebra.\nFor student’s at Universities, I’d check with the library to see if you can get a free pdf copy of the book if you’re interested. The textbook itself isn’t absurdly expensive either ($50-60). Update: Axler is apparently working on a 4th edition of the book, which he plans to be open access. Axler also has video lectures on YouTube to go along with the book too.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1668706815,"objectID":"74f7fb04a75e766307d398251c369a21","permalink":"https://www.jameswright.xyz/resources/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/resources/","section":"","summary":"Table of Contents Programming/Computer Science Mathematics Here are various websites, papers, blog posts, and textbooks that I often recommend to people, or find really useful in general.\nProgramming/Computer Science Learn Git Branching Interactive website with great visualizations that teaches how to use git and, most importantly, what the commands are actually doing. I recommend this website to anyone who is wanting to get a “proper” understanding of how to use git, or even for general beginners who might not necessarily know the basic commands yet.","tags":null,"title":"Resources","type":"page"},{"authors":["James Wright","Jed Brown","Kenneth Jansen","Leila Ghaffari"],"categories":[],"content":"","date":1680016968,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1680020148,"objectID":"9de15a155bc26db51c6327cf3ad2c810","permalink":"https://www.jameswright.xyz/publication/siam_cse23_implicit_srs_with_libceed/","publishdate":"2023-03-28T09:22:48-06:00","relpermalink":"/publication/siam_cse23_implicit_srs_with_libceed/","section":"publication","summary":"Presentation of developments in using libCEED and PETSc for compressible flow simulation. The resulting code is portable to diverse hardware and performance is demonstrated.","tags":["libCEED","PETSc"],"title":"Performance-Portable Implicit Scale-Resolving Compressible Flow Using libCEED","type":"publication"},{"authors":["James Wright"],"categories":["Notes"],"content":" Table of Contents Intro Interpolation Fundamentals Collocation Overview Collocation for a Generic Differential Equation Defining the Solution Function Defining the Constraints Determining the Collocation Points Creating the System of Equations Matrix Form Residual form Example PDE: Poisson Creating the System of Equations Appendix A: Determining Collocation Points Continued How many? Where should the collocation points be located? Intro Collocation methods are a way of approximately solving differential equations (both partial and ordinary). They are very simple to code and implement.\nThis article will cover collocation methods as an extension of simple interpolation. If you’re not familiar with interpolation theory, see Interpolation Theory 101. Even if you are, I’ll give a quick rundown of the parts of interpolation theory that you’ll need for this article:\nInterpolation Fundamentals We want to find a function $g(x)$ such that it meets a set of $m+1$ constraints $g(x_i) = y_i$ We assume $g(x)$ to be of the form $g(x) = \\sum_{i=0}^N c_i \\phi_i(x)$ 1 To ensure existence and uniqueness of the solution, we prescribe that the number of degrees-of-freedom (DOFs) $N+1$ equals the number of constraints $m+1$ Expanding $g(x)$ for each constraint results in a system of equations with $N+1$ DOFs and $m+1$ equations. Normal interpolation sets constraints on the value of the function $g$ itself. I also introduced slope constraints, which sets a constraint on the slope of the polynomial rather than the polynomial itself.\nCollocation is a further continuation of that; we set the constraint(s) that the function must satisfy a differential equation at select locations.\nCollocation Overview In collocation, we’re doing the exact same procedure as in interpolation, but with different constraints. These constraints come in two forms:\nBoundary conditions Satisfying a differential equation Boundary condition constraints look identical to normal interpolation constraints; we prescribe the value of our function (or of the function derivative) at some specific location.2 The satisfaction of the differential equation is where things are a bit more interesting.\nCollocation for a Generic Differential Equation For a given differential equation (DE), assume we can write it in the form:\n$$\\mathcal{L}(u) = f$$\nfor $\\mathcal{L}$ the DE operator, $u$ the solution function, and $f$ some source function. For example, the Poisson PDE is given by $u’’(x) = f$, therefore $\\mathcal{L}(u) = u’’$. Another, more complicated example, would be the Blasius Boundary layer equation, which is given as $2u’’’ + u’’ u = 0$. In this case, $\\mathcal{L}(u) = 2u’’’ + u’’ u$.\nThe DE is subject to boundary conditions (and/or initial conditions). We will assume that the domain of the problem is $x = [0,1]$, and thus the boundaries are at $x=0$ and $x=1$. We assume two boundary conditions, though generally the number of boundary conditions for a general DE is determined by\n$$ \\begin{align*} u\u0026#39;(1) \u0026amp;= a \\\\ u\u0026#39;\u0026#39;(1) \u0026amp;= b \\end{align*} $$ Defining the Solution Function Following the steps from interpolation, we need to assume a form for our function. We’ll denote this function as $u^h$, which will be an approximate solution to the PDE. We assume the form:\n$$u^h(x) = \\sum_{n=0}^N c_n \\phi_n(x)$$\nwhere $c_n$ are our DOFs/coefficients and $\\phi_n(x)$ are our basis functions. The choice of $\\phi_n(x)$ is left arbitrary for this article. A few options are Legendre, Laguerre, and Chebyshev polynomials (which all have their own special properties, not discussed here), or non-polynomial basis functions, such as the Fourier series.\nBy defining $u=u^h$, we approximate the continuous PDE given above as: $$ \\begin{align*} \\mathcal{L}(u^h) \u0026amp;= f \\\\ u\u0026#39;^{\\,h}(1) \u0026amp;= a \\\\ u\u0026#39;\u0026#39;^{\\,h}(1) \u0026amp;= b \\end{align*} $$ Defining the Constraints Before we determine the number of DOFs ($N+1$), we need to know the number of constraints. I’ve already mentioned that the boundary conditions represent constraints, so each boundary condition represents a constraint. We’ll denote the number of boundary constraints as $m_b$.\nBut for “Satisfying the differential equation”, the PDE is defined for the entire domain, not discrete locations. This is equivalent to defining an infinite number of constraints, one for for every possible location within the domain. This is obviously not feasible.\nTherefore, we choose a select number of locations in the domain to enforce the PDE. The locations that we use are called collocation points. We’ll denote the number of collocation points as $m_c$.\nSo the total number of constraints are the number of boundary conditions plus the number of collocation points. Since we need the number of DoFs to match the number of constraints (see Interpolation Theory 101), we get:\n$$N + 1 = m_b + m_c $$\nDetermining the Collocation Points We still need to determine how many collocation points and where on the domain they should be. This is a more nuanced discussion, so I’ve moved a more detailed …","date":1664127256,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664905507,"objectID":"da39a8cb5c2061c9c8b650e4789e1258","permalink":"https://www.jameswright.xyz/post/20220925/collocation-methods-from-interpolation/","publishdate":"2022-09-25T11:34:16-06:00","relpermalink":"/post/20220925/collocation-methods-from-interpolation/","section":"post","summary":"An introduction to collocation methods for differential equations, from the perspective of interpolation theory. I explain how collocation methods are more-or-less identical to interpolation methods, with the only difference being the constraints applied to the problem.","tags":["math","differential equations","numerical methods"],"title":"Collocation Methods from Interpolation","type":"post"},{"authors":["James Wright"],"categories":["Notes"],"content":" Table of Contents Interpolation Problem Intro Polynomial order Solving the interpolation problem For arbitrary function basis Slope constraints Appendix A: Further thoughts on non-polynomial functions Required Degrees-of-freedom for $g(x)$ Non-linear $g(x)$ with respect to degrees-of-freedom Pre-requisites: There are a few assumptions made for the reader’s background. Mainly, that you’re familiar with the concept of a basis in the linear algebra sense and, in particular, function space bases (such as the monomials). Also, being familiar with turning a system of linear equations into it’s equivalent matrix form would be beneficial. Interpolation Problem Intro In interpolation, we wish to find a function $g(x)$ that satisfies $g(x_i) = y_i$ for some positive number $i$. We’ll call these constraints on the function $g(x)$. We say that the constraint is satisfied if $g(x)$ passes through the point $(x_i, y_i)$.\nIn the case of polynomial interpolation, we assume a form $$g(x) = \\sum_{n=0}^N c_n \\phi_n(x)$$\nwhere $\\phi_n(x)$ represents some set of basis functions. The simplest case of this is the monomials, where $\\phi_n(x) = x^n$, such that:\n$$g(x) = c_0 + c_1 x + c_2 x^2 + \\dots + c_N x^{N}$$\nThis forms a basis for the space of $N$th order polynomials. However, we can choose $\\phi_n$ to be any set of basis functions for polynomials, such as the Legendre, Laguerre, and Chebyshev polynomials (which all have their own special properties, not discussed here). You can even have non-polynomial basis functions, such as the Fourier series.\nFor just right now though, I’ll stick to talking about $g(x)$ living in the space of polynomials.\nPolynomial order A question does remain though: What kind (order) of polynomial should we try to interpolate with?\nWell, if we have $m+1$ constraints, then we need, at minimum, a $m$th order polynomial to interpolate them. For example, we need 2 points ($m+1=2 \\ \\therefore m=1$) to make a line ($N = m = 1$ order polynomial).\nSo what about polynomials greater than order $m$? Well, then an infinite number polynomials satisfy the constraints. Example: If we only have 1 constraint ($m+1=1 \\ \\therefore m=0$) and there are an infinite number of lines that can satisfy that constraint.\nWe’d like for a solution to the problem to exist ($N \\geq m$) and for that solution to be unique ($N \u0026lt; m+1$). Therefore, the order of the polynomial should be one less than the number of constraints ($N = m$).\nAlternative Thought Process An alternative way of thinking about it is that our constraints setup $m+1$ equations. To find a solution, we must have the number of unknowns match the number of equations. Since a $N$th order polynomial has $N+1$ unknowns, then $N + 1 = m + 1 \\ \\rightarrow \\ N = m$.\nSolving the interpolation problem Now we have $m+1$ constraints, and know that $g(x)$ should be a $N = m$ order polynomial. So how do find $g(x)$?\nThe most straight forward way is to simply plug the constraints into $g(x)$. Doing this gives us the set of linear equations:\n\\begin{align*} g(x_0) \u0026amp;= c_0 + c_1 x_0 + c_2 x_0^2 + \\dots + c_N x_0^{N} \u0026amp;= y_0 \\\\ g(x_1) \u0026amp;= c_0 + c_1 x_1 + c_2 x_1^2 + \\dots + c_N x_1^{N} \u0026amp;= y_1 \\\\ \\vdots \\\\ g(x_m) \u0026amp;= c_0 + c_1 x_m + c_2 x_m^2 + \\dots + c_N x_m^{N} \u0026amp;= y_m \\\\ \\end{align*} We turn this into a matrix problem that looks like:\n$$ \\begin{bmatrix} 1 \u0026amp; x_0 \u0026amp; x_0^2 \u0026amp; \\dots \u0026amp; x_0^{N} \\\\[2pt] 1 \u0026amp; x_1 \u0026amp; x_1^2 \u0026amp; \\dots \u0026amp; x_1^{N} \\\\[2pt] \\vdots \\\\[2pt] 1 \u0026amp; x_m \u0026amp; x_m^2 \u0026amp; \\dots \u0026amp; x_m^{N} \\\\[2pt] \\end{bmatrix} \\begin{bmatrix} c_0 \\\\ c_1 \\\\ \\vdots \\\\ c_N \\\\ \\end{bmatrix} = \\begin{bmatrix} y_0 \\\\ y_1 \\\\ \\vdots \\\\ y_m \\\\ \\end{bmatrix} $$ The matrix above is known as a Vandermonde matrix. By solving this system, we find the coefficients $c_n$ that we can then reconstruct into $g(x) = \\sum_{n=0}^N c_n x^n$.\nFor arbitrary function basis Remember that we chose $\\phi_n(x) = x^n$, which are the monomial bases. This works fine, but the resulting problem is very difficult to solve computationally (it is ill-conditioned). Other choices of $\\phi_n(x)$ can help reduce the difficulty significantly, such as the aforementioned Chebyshev polynomials. In fact, we don’t even need $\\phi_n(x)$ to be defined by a polynomial. For example, we could choose the Fourier series (so $g(x) = c_0 + \\sum_{n=1}^N c_n \\cos(nx) + s_n \\sin(nx)$). This is discussed in more detail below.\nRegardless of the choice of your basis functions, there’s one primary question: How do we go about finding the interpolating function using other bases?\nAnswer: We create a different matrix to solve with. Recall that we defined $g(x) = \\sum_{n=0}^N c_n \\phi_n(x)$. Using an arbitrary $\\phi_n(x)$ instead of the monomials $x^n$, we can apply each constraint, expand our definition of $g(x)$, and get the following system of equations:\n$$ \\begin{align*} g(x_0) \u0026amp;= c_0\\phi_0(x_0) + c_1 \\phi_1(x_0) + \\dots + c_N \\phi_N(x_0) \u0026amp;= y_0 \\\\ g(x_1) \u0026amp;= c_0\\phi_0(x_1) + c_1 \\phi_1(x_1) + \\dots + c_N \\phi_N(x_1) \u0026amp;= y_1 \\\\ \\vdots \\\\ g(x_m) \u0026amp;= c_0\\phi_0(x_m) + c_1 …","date":1664120846,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1664905507,"objectID":"9aa89aa1c1f500cbbd62f716d12409b7","permalink":"https://www.jameswright.xyz/post/20220925/interpolation-theory-101/","publishdate":"2022-09-25T09:47:26-06:00","relpermalink":"/post/20220925/interpolation-theory-101/","section":"post","summary":"A quick overview of the basics of interpolating a set of function points using a polynomial. This servers as a percursor to a (future) post on collocation methods","tags":["math"],"title":"Interpolation Theory 101","type":"post"},{"authors":["James R. Wright","Riccardo Balin","Kenneth E. Jansen","John A. Evans"],"categories":null,"content":"","date":1611100800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1613147809,"objectID":"2c4e97da7adcf90640b9edf155a7b459","permalink":"https://www.jameswright.xyz/publication/wright-unstructured-dns-turbulent/","publishdate":"2021-01-22T20:56:56.706386Z","relpermalink":"/publication/wright-unstructured-dns-turbulent/","section":"publication","summary":"Introduce the LESDNS simulation framework for developing turbulence models. The proposed framework is then applied onto the Gaussian speed-bump problem and compared to other simulation results, including DNS and WMLES.","tags":["PHASTA","Gaussian Speed-Bump","LES_DNS"],"title":"Unstructured LES_DNS of a Turbulent Boundary Layer over a Gaussian Bump","type":"publication"},{"authors":["James Wright"],"categories":["Notes"],"content":"The gradient of velocity is generally easy to compute in most CFD post-processing routines. But let’s say you want to find the wall shear stress from this quantity, how would you do that? I’d been searching for an answer to this question and could never really find one (or at least one that was satisfying). Eventually I derived out the following solution and figured I’d post it so that the information was more widely available.\nInitial Definitions First, let’s define more explicitly what we’re trying to find. The wall shear stress is often given as:\n$$ \\tau_w = \\mu \\left (\\frac{\\partial u}{\\partial y}\\right ) \\Bigg\\rvert_{y=\\text{wall}} $$\nHowever, this isn’t very explicit and really only applies to flat plate boundary layer flows. I’d submit that the “real” definition is dynamic viscosity ($\\mu$) times the wall-normal gradient of velocity tangential to the wall taken at the wall, or:\n$$ \\tau_w = \\mu \\left (\\frac{\\partial u_\\parallel}{\\partial n}\\right ) \\Bigg\\rvert_{n=0} $$\nThis will result in a vector parallel to the wall in the direction of the wall shear stress.\nI’ll define the velocity gradient as a tensor $E_{ij}\\ $:\n$$ E_{ij} = \\frac{\\partial u_i}{\\partial x_j} = \\partial_j u_i$$\nNote that $E_{ij}$ is not symmetric and that $\\partial_j$ is still an operator with $u_i$ as it’s input, not multiplication.\nLastly, we have the common form of projecting a vector onto a plane given its normal vector:\n$$ \\text{proj}_{\\hat n}(\\overrightarrow{u}) = \\overrightarrow{u} - (\\overrightarrow{u} \\cdot \\hat n) \\hat n = u_i - (u_j \\hat n_j) \\hat n_i$$\nwhere $\\hat n$ is the wall-normal unit vector. The right most term is in index summation notation.\nPreamble Assumptions We have a wall-normal unit vector $\\hat n_i$ We have the velocity gradient tensor $E_{ij} = \\partial_j u_i$ Goal Obtain:\n$$ \\left (\\frac{\\partial u_\\parallel}{\\partial n}\\right ) \\Bigg\\rvert_{n=0} = \\left (\\partial_{\\hat n} u_\\parallel\\right ) \\big\\rvert_{n=0} = f(E_{ij}, \\hat n) = f(\\partial_j u_i, \\hat n)$$\nSolution For the impatient, the solution is:\n$$ \\left (\\frac{\\partial u_\\parallel}{\\partial n}\\right ) \\Bigg\\rvert_{n=0} = \\bigg( \\big[(\\delta_{ik} - \\hat n_k \\hat n_i) \\hat n_j \\big] E_{kj} \\bigg) \\Bigg\\rvert_{n=0} = f(\\hat n, E_{ij})$$\nThe derivation of the above equation is given below.\nDerivation Notice that the wall shear gradient can be broken into two “terms”:\ngradient in the wall-normal direction velocity tangent to the wall First we’ll define these two “terms” individually\nGradient in the Wall-Normal Direction This is simply:\n$$\\hat n_j \\partial_j$$\nGradient in a specific direction should result in a tensor whose rank is the same as it’s input. In other words, the gradient of a scalar in a single direction should result in a scalar (which is a rank 0 tensor). The summation over the $j$ index shows that this is true.\nVelocity Tangent to the Wall Taking the vector projection formula from Initial Definitions, this is fairly straight forward:\n$$ u_{i,\\parallel} = u_i - (u_k \\hat n_k) \\hat n_i$$\nCombining Terms Putting these together, we get:\n$$\\underbrace{\\hat n_j \\partial_j}_{\\partial_{\\hat n}} [\\underbrace{u_i - (u_k \\hat n_k) \\hat n_i }_{u_{\\parallel}}]$$\n$$\\Rightarrow \\hat n_j \\partial_j \\left [u_k (\\delta_{ik} - \\hat n_k \\hat n_i) \\right]$$\nUsing product rule:\n$$ \\Rightarrow (\\delta_{ik} - \\hat n_k \\hat n_i) \\hat n_j \\partial_j (u_k) + u_k \\hat n_j \\partial_j (\\delta_{ik} - \\hat n_k \\hat n_i)$$\nFirst, let’s work with the right hand term (RHT):\n$$ \\text{RHT} = u_k \\hat n_j \\partial_j (\\delta_{ik} - \\hat n_k \\hat n_i) $$\n$$\\Rightarrow u_k \\left [\\hat n_j \\partial_j (\\delta_{ik}) - \\hat n_j \\partial_j (\\hat n_k \\hat n_i) \\right ]$$\nThe Kronecker delta is invariant of spacial dimensions, so the left term goes to zero. Then we can do product rule again on the right term.\n$$\\Rightarrow u_k \\left [\\hat n_j \\cancelto{0}{\\partial_j (\\delta_{ik})} - \\hat n_j \\partial_j (\\hat n_k \\hat n_i)) \\right ]$$\n$$\\Rightarrow -u_k \\left [\\hat n_i \\hat n_j \\partial_j (\\hat n_k) + \\hat n_k \\hat n_j \\partial_j (\\hat n_i) \\right ]$$\nHere, $\\hat n$ is not invariant of spacial location; if you have a non-flat surface, it will change as you move along the wall. However, note that $\\hat n_j \\partial_j$ is the gradient in the wall-normal direction. The $\\hat n$ does not change in the wall-normal direction; it only change in the wall-parallel direction. Thus:\n$$\\Rightarrow -u_k \\left [\\hat n_i \\cancelto{0}{\\hat n_j \\partial_j (\\hat n_k)} + \\hat n_k \\cancelto{0}{\\hat n_j \\partial_j (\\hat n_i)} \\right ]$$\n$$ \\therefore \\text{RHT} = 0 $$\nMoving back to the original expression, we’re then left with:\n$$ \\partial_{\\hat n} u_{i,\\parallel} = (\\delta_{ik} - \\hat n_k \\hat n_i) \\hat n_j \\partial_j (u_k) + \\cancelto{0}{u_k \\hat n_j \\partial_j (\\delta_{ik} - \\hat n_k \\hat n_i)}$$\nNote that we already have the gradient of velocity in the last term, thus:\n$$ \\partial_{\\hat n} u_{i,\\parallel} = (\\delta_{ik} - \\hat n_k \\hat n_i) \\hat n_j E_{kj} $$\n$$ \\therefore \\left (\\frac{\\partial …","date":1597333787,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644341688,"objectID":"84455701cdacc23c2e28a73fa1eb2e39","permalink":"https://www.jameswright.xyz/post/20200813/calculate_wall_shear_from_velocity_gradient/","publishdate":"2020-08-13T09:49:47-06:00","relpermalink":"/post/20200813/calculate_wall_shear_from_velocity_gradient/","section":"post","summary":"If the gradient of velocity is already calculated, how could you get the wall-shear gradient for any arbitrary wall? The aim of this post is to answer that question and give the reasoning for the result.","tags":["math","fluids","CFD"],"title":"Calculate Wall Shear Gradient from Velocity Gradient","type":"post"},{"authors":["James Wright"],"categories":["Notes"],"content":"Definitions and Useful Tools Notation The vorticity transport equation can simply be calculated by taking the curl of the conservation of momentum evolution equations. See my earlier post going over expressing curl in index summation notation. In summary, the curl of a vector $a_j$ can be expressed as:\n$$ \\nabla \\times a_j = b_k \\ \\Rightarrow \\ \\varepsilon_{ijk} \\partial_i a_j = b_k $$\nwhere $\\varepsilon_{ijk}$ is the Levi-Civita symbol.\nNote that I’ll be using shorthand to express the differential operator, $\\partial_\\phi$, where the index $\\phi$ is the index of a spacial variable except for $t$, which represents a time derivative:\n$$ \\frac{\\partial}{\\partial x_i} = \\partial_i \\quad \\mathrm{and} \\quad \\frac{\\partial}{\\partial t} = \\partial_t$$\nFor double derivatives, a superscript will be used:\n$$ \\frac{\\partial}{\\partial x_i} \\frac{\\partial}{\\partial x_i} = \\frac{\\partial^2}{\\partial x_i^2} = \\partial_i^2 $$\nMath Properties Some useful properties of the Levi-Civita symbol that will be used are that it is commutative in multiplication and, since it is invariant of space and time, it can be brought in or outside a differential operator operator like a constant:\n$$ \\varepsilon_{ijk}\\frac{\\partial}{\\partial x_i} (\\phi ) = \\frac{\\partial}{\\partial x_i} (\\varepsilon_{ijk} \\phi ) $$\nUsing the product identity of permutation tensors , you can also convert permutation tensors into Kronecker deltas, $\\delta_{ij}$:\n$$ \\varepsilon_{ijk} \\varepsilon_{imn} = \\delta_{jm}\\delta_{kn} - \\delta_{jn}\\delta_{km} $$\nHint: To convert from some arbitrary pair of Levi-Civita symbols that share one index, first rearrange their indices such that the shared index is the first for both. Then, the ordering of the Kronecker delta indices is $ \\delta_{a_2\\ b_2} \\delta_{a_3\\ b_3} - \\delta_{a_2\\ b_3} \\delta_{a_3\\ b_2}$ , where $a_i$ and $b_i$ represent the indices of the different Levi-Civita symbols and their subscripts represent which index is placed in that Kronecker delta. Speaking of Kronecker deltas, they have the handy effect of changing indices:\n$$ \\delta_{ij} a_i = a_j $$\nDifferential operators are order invariant:\n$$ \\partial_i (\\partial_j (u_k)) = \\partial_j (\\partial_i (u_k))$$\nI will be dropping the use of parentheses for the differential operator, but note that it is an operator and is not commutative: $\\partial_i u_j \\neq u_j \\partial_i$ With that taken care of, onto the derivation!\nCurl of Momentum Evolution The index notation form of the incompressible momentum evolution (or conservation of momentum equations) is:\n$$ \\partial_t u_i + u_j \\partial_j u_i = - \\tfrac{1}{\\rho} \\partial_i p + \\nu \\partial_j^2 u_i $$\nVorticity, $\\omega_k$, is given as the curl of velocity, or:\n$$ \\nabla \\times u_j = \\omega_k \\ \\Rightarrow \\ \\varepsilon_{ijk} \\partial_i u_j = \\omega_k $$\nTo get vorticity evolution, we can take the curl of the momentum transport equations:\n$$ \\nabla \\times [\\partial_t u_i + u_j \\partial_j u_i = - \\tfrac{1}{\\rho} \\partial_i p + \\nu \\partial_j^2 u_i ]$$\nIn index notation, this is the equivalent of multiplying by the Levi-Civita symbol and a corresponding differential operator:\n$$ \\Rightarrow \\varepsilon_{k\\ell i} \\partial_\\ell [\\partial_t u_i + u_j \\partial_j u_i = - \\tfrac{1}{\\rho} \\partial_i p + \\nu \\partial_j^2 u_i ]$$\nDistributing this across the terms, we get:\n$$ \\begin{align} \\underbrace{\\varepsilon_{k\\ell i} \\partial_\\ell \\partial_t u_i}\\text{Temporal Term} + \\underbrace{\\varepsilon{k\\ell i} \\partial_\\ell u_j \\partial_j u_i}\\text{Advection Term} \u0026amp; = \\underbrace{- \\varepsilon{k\\ell i} \\partial_\\ell \\tfrac{1}{\\rho} \\partial_i p}\\text{Pressure Term} + \\underbrace{\\varepsilon{k\\ell i} \\partial_\\ell \\nu \\partial_j^2 u_i}_\\text{Viscous Term} \\\\ \\Rightarrow \\quad \\mathbb{T} + \\mathbb{A} \u0026amp; = \\mathbb{P} + \\mathbb{V} \\end{align}$$\nWe’ll treat the named terms individually, then put them back together. I’ll leave the advection term for last since it’s more involved than the other three.\nIndividual Terms Temporal Term $\\mathbb{T}$ $$\\mathbb{T} = \\varepsilon_{k\\ell i} \\partial_\\ell \\partial_t u_i $$\nUsing the order invariance of derivatives and moving $\\varepsilon_{k\\ell i}$ inside the derivative operators, we can get the following:\n$$ \\Rightarrow \\quad \\partial_t \\varepsilon_{k\\ell i} \\partial_\\ell u_i $$\nSince we know that $\\omega_k = \\varepsilon_{k\\ell i} \\partial_\\ell u_i$, then we can write:\n$$\\mathbb{T} = \\partial_t \\omega_k $$\nPressure Term $\\mathbb{P}$ $$ \\mathbb{P} = - \\varepsilon_{k\\ell i} \\partial_\\ell \\tfrac{1}{\\rho} \\partial_i p $$\nFirst we can move the density term out of the derivatives:\n$$ \\Rightarrow \\quad - \\tfrac{1}{\\rho} \\varepsilon_{k\\ell i} \\partial_\\ell \\partial_i p $$\nThe next step can go one of two ways. First you can simply use the fact that the curl of a gradient of a scalar equals zero ($\\nabla \\times (\\partial_i \\phi) = \\mathbf{0}$). Or, you can be like me and want to prove that it is zero. I’ll probably do the former here, and put the latter in a separate post. Using the first method, we get …","date":1595429512,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644341688,"objectID":"6f866e4599139c87115e213b0245d0ba","permalink":"https://www.jameswright.xyz/post/20200722/vorticity_transport_index_notation/","publishdate":"2020-07-22T08:51:52-06:00","relpermalink":"/post/20200722/vorticity_transport_index_notation/","section":"post","summary":"How to derive the vorticity transport equation using index summation notation.","tags":["math","fluids","Levi-Civita"],"title":"Deriving Vorticity Transport in Index Notation","type":"post"},{"authors":["James Wright"],"categories":["Notes"],"content":"Here are some brief notes on performing a cross-product using index notation. This requires use of the Levi-Civita symbol, which may also be called the permutation tensor.\nLevi-Civita Symbol The Levi-Civita symbol is often expressed using an $\\varepsilon$ and takes the following definition:\n$$ \\varepsilon_{ijk} = \\begin{cases} +1 \u0026amp; \\text{if } (i,j,k) \\text{ is even permutation,} \\\\ -1 \u0026amp; \\text{if } (i,j,k) \\text{ is odd permutation,} \\\\ 0 \u0026amp; \\text{if } i = j, \\text{ or } j = k, \\text{ or } k = i \\end{cases} $$\nFor a 3D system, the definition of an odd or even permutation can be shown in Figure 1.\nPermutation pattern for Levi-Civita symbol in 3D. Altered from source. The permutation is even if the three numbers of the index are in “order”, given allowance to cycle back through the numbers once the end is reached. So if you skip to the 1 value in the index, going left-to-right should be in numerical order. For example, if given 321 and starting with the 1 we get 1 $\\rightarrow$ 3 $\\rightarrow$ 2. 132 is not in numerical order, thus it is an odd permutation.\nSo given $\\varepsilon_{ijk}\\,$, if $i$, $j$, and $k$ are $123$, $231$, or $312$, then $\\varepsilon_{ijk}=1$. Note that the order of the indicies matter. If instead we’re given $\\varepsilon_{jik}$ and any of the three permutations in the previous example, then the expression would be equal to $-1$ instead.\nCross Products in Index Notation Now we get to the implementation of cross products. This involves transitioning back and forth from vector notation to index notation. A vector and it’s index notation equivalent are given as:\n$$ \\mathbf{a} = a_i$$\nIf we want to take the cross product of this with a vector $\\mathbf{b} = b_j$, we get:\n$$ \\mathbf{a} \\times \\mathbf{b} = a_i \\times b_j \\ \\Rightarrow \\varepsilon_{ijk} a_i b_j = c_k$$\nNote the indices, where the resulting vector $c_k$ inherits the index not used by the original vectors. Also note that since the cross product is anticommutative (ie. $\\mathbf{a} \\times \\mathbf{b} = - \\mathbf{b} \\times \\mathbf{a}$ ), changing the order of the vectors being crossed requires changing the indices of the Levi-Civita symbol or adding a negative:\n$$ b_j \\times a_i \\ \\Rightarrow \\ \\varepsilon_{jik} a_i b_j = -\\varepsilon_{ijk} a_i b_j = c_k$$\nConversely, the commutativity of multiplication (which is valid in index notation) means that the vector order can be changed without changing the permutation symbol indices or anything else:\n$$ b_j \\times a_i \\ \\Rightarrow \\ \\varepsilon_{jik} a_i b_j = \\varepsilon_{jik} b_j a_i$$\nRule(s) of Thumb for Setting Indices Correctly Start the indices of the permutation symbol with the index of the resulting vector. This will often be the free index of the equation that the cross product lives in and I normally like to have the free index as the leading index in multi-index terms.\nThe next two indices need to be in the same order as the vectors from the cross product. Using these rules, say we want to replicate $a_\\ell \\times b_k = c_j$. Then the first index needs to be $j$ since $c_j$ is the resulting vector. The other 2 indices must be $\\ell$ and $k$ then. This results in:\n$$ a_\\ell \\times b_k = c_j \\quad \\Rightarrow \\quad \\varepsilon_{j\\ell k} a_\\ell b_k = c_j$$\nCurl in Index Notation The curl is given as the cross product of the gradient and some vector field:\n$$ \\mathrm{curl}({a_j}) = \\nabla \\times a_j = b_k $$\nIn index notation, this would be given as:\n$$ \\nabla \\times a_j = b_k \\ \\Rightarrow \\ \\varepsilon_{ijk} \\partial_i a_j = b_k $$\nwhere $\\partial_i$ is the differential operator $\\frac{\\partial}{\\partial x_i}$.\nNote that $\\partial_k$ is not commutative since it is an operator. It may be better to write $\\partial_k u_i$ as $\\partial_k (u_i)$ to more explicitly denote it’s nature as an operator on $u_i$. These follow the same rules as with a normal cross product, but the first “vector” is always going to be the differential operator. Since $\\nabla$ is hardly ever defined with an index, the rule of thumb can come in handy when trying to translate vector notation curl into index notation.\nFor example, if I have a vector $u_i$ and I want to take the curl of it, first I need to decide what I want the resulting vector index to be. Let’s make it be $\\ell$. Due to index summation rules, the index we assign to the differential operator may be any character that isn’t $i$ or $\\ell$ in our case. Let’s make it be $k$. Putting that all together we get:\n$$ \\mathrm{curl}(u_i) = \\varepsilon_{\\ell ki} \\partial_k u_i = \\omega_\\ell $$\n","date":1595376045,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644341688,"objectID":"b6cb5c8e7627a97272a391eefccb802b","permalink":"https://www.jameswright.xyz/post/20200721/cross_product_and_curl_in_index_notation/","publishdate":"2020-07-21T18:00:45-06:00","relpermalink":"/post/20200721/cross_product_and_curl_in_index_notation/","section":"post","summary":"Review of how to perform cross products and curls in index summation notation. In essence, this ends up being an overview on how to apply the Levi-Civita symbol in these contexts.","tags":["index notation","Levi-Civita","math"],"title":"Cross Product and Curl in Index Notation","type":"post"},{"authors":["James Wright"],"categories":["Tutorials"],"content":" Hugo Academic theme has now changed it’s name to Wowchemy. I’ve updated the names and links in the post to reflect the change. This tutorial will assume that\nYou have a repository containing the Wowchemy source code You have a GitHub Pages repository You have a general grasp of GitHub and git concepts (repos, pushing, etc.) Resources for creating your Wowchemy website can be found at the Wowchemy website. For setting up your own (free) GitHub Pages repository, see the GitHub Pages Website. If you have neither of these pre-requisites done, go get them done and come back here. Don’t worry, I can wait. 😉\ntl;dr Copy and edit Workflow YAML file Put Workflow YAML file in .github/workflows/ directory in Source repo Create personal access token Store personal access token in secret in Source repo Push Source repo (with the Workflow YAML file) Watch GitHub do all the work for you I talk about two primary repositories in this tutorial: a “Source” repo and a “Pages” repo.\nSource Repo: Contains the Hugo source files (markdown, config, etc.) Pages Repo: The directory from which a GitHub Pages website is deployed Overview This tutorial goes over how to take a website built using Wowchemy and host that website using a GitHub Pages website. This website you’re viewing right now is run using this exact process. The beauty of hosting it on GitHub Pages is that:\nIt is free You can setup a custom domain name with it easily It integrates well with automated deployment By default, GH Pages will suggest you use Jekyll for creating the website. I have nothing against using Jekyll to build a website, but the Wowchemy theme is great for, well, academics and researchers.\nThe way GitHub Pages sites work is that, assuming Jekyll files are not present, they will simply display any static website that is present in the repository. Thus, if we take the static site files that Hugo generates and then place them in the Pages repository, voila! We have a Hugo site deployed on GH Pages.\nTechnically you could do this process manually; on your local machine generate the static site files in the Hugo Source repository, copy them to the GH Pages repository, and git push that. But that’s a hassle and there’s a better way: GitHub Actions.\nUsing GitHub Actions (GitHub’s flavor of CI/CD automation), we can automate the process as follows:\nPush local changes to your Source repo’s master branch A GitHub Action Workflow will then: Clone the Source repo Build the Hugo website Clone the GH Pages repo Copy the static site files from Source repo to Pages repo Push those changes to the Source repo GitHub Pages publishes the static files that were pushed to the Pages repo GitHub Action Workflow So how do we do this? Well it all relies on GitHub Actions to do all the work. We use GitHub Actions by defining a Workflow in the form of a yaml file in the .github/workflows directory of the repository. For our present use case, the file looks like this:\nname: Build and Deploy on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: Checkout master uses: actions/checkout@v1 with: submodules: true - name: Hugo Deploy GitHub Pages uses: benmatselby/hugo-deploy-gh-pages@master env: HUGO_VERSION: 0.68.3 TARGET_REPO: jrwrigh/jrwrigh.github.io TOKEN: ${{ secrets.TOKEN }} CNAME: www.jameswright.xyz I’ll go over the different parts, but you can find more details about GitHub Actions GitHub Documentation here and about the syntax of the Workflow yaml file here\nName name: Build and Deploy This is simply the name of the GitHub Workflow that you’re going to make. This is what will show up in the GitHub Workflows dashboard of the repository.\nTrigger on: push: branches: - master This tells GitHub when to run the Workflow. Here, we want it to trigger on a push to the master branch.\nBuild Job jobs: build: runs-on: ubuntu-latest steps: This section starts the declaration of what the Workflow should actually do. A Workflow is made up of individual jobs. Here, we only need one job: build.\nFirst, the operating system is specified for the build job. The proceeding steps rely on access to apt-get to install the required software to build the static site files, so Ubuntu is chosen.\nAfter this, the steps for the build job are listed. These are what define what the job actually does. These steps can be defined different ways, but we’re going to be using only Actions. Actions are just predefined scripts that are published on GitHub’s marketplace (though you can reference unpublished ones if they’re in a public repository).\nCheckout Action - name: Checkout master uses: actions/checkout@v1 with: submodules: true This simply clones (or checkout in GitHub’s nomenclature) the Source repository to the container. It is one of GitHub’s default actions.\nNote: The submodules: true is quite important, as the Wowchemy theme runs as a submodule in your Source repository. If that wasn’t set, Hugo wouldn’t be able to build the site.\nBuild and Deploy Action - name: Hugo Deploy GitHub …","date":1586484291,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1644341688,"objectID":"29cae33254f50a7411cbc6662d24692c","permalink":"https://www.jameswright.xyz/post/20200409/deploy_wowchemy_to_githubio/","publishdate":"2020-04-09T20:04:51-06:00","relpermalink":"/post/20200409/deploy_wowchemy_to_githubio/","section":"post","summary":"This tutorial goes over how to take a website built using Hugo and Wowchemy (formerly Academic) and host that website using GitHub Pages. More specifically, it goes over how to automate the deployment of a Hugo site using GitHub Actions. This website you're viewing right now is run using this exact process.","tags":["Hugo Academic","GitHub Pages","GitHub Actions","CI/CD","Hugo","Wowchemy"],"title":"Automate Deployment of Wowchemy Website onto GitHub Pages","type":"post"},{"authors":["Riccardo Balin","James Wright","John Patterson","John A Farnsworth","John A Evans","Raj Lakhani","Philippe Spalart","Kenneth E Jansen"],"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1611350775,"objectID":"a740b52e6dfd33158712da48ef5667f1","permalink":"https://www.jameswright.xyz/publication/scitech_2020/","publishdate":"2020-01-16T22:10:33.314016Z","relpermalink":"/publication/scitech_2020/","section":"publication","summary":"Simulations of the NASA Wing Juncture problem using the open-source PHASTA solver. Results from SA and DDES turbulence models with adaptive refinement are examined.","tags":["Hybrid Turbulence Models","PHASTA","NASA Wing Juncture"],"title":"Hybrid Turbulence Model Computations of the NASA Juncture Flow Model Using PHASTA","type":"publication"},{"authors":["James Ray Wright III"],"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1591663359,"objectID":"1b8a29130583999625f6bb144767699b","permalink":"https://www.jameswright.xyz/publication/jameswright-static-pressure-recovery/","publishdate":"2020-06-09T00:38:07.022803Z","relpermalink":"/publication/jameswright-static-pressure-recovery/","section":"publication","summary":"Conical diffusers are used in hundreds of engineering applications in various industries. Some of the operating conditions that they operate under cause swirling flow to enter the diffuser. It is generally well documented that the addition of swirl to the flow of a diffuser allows for greater divergence angles without wall separation, resulting in better overall performance of the diffuser and the machine it's attached to. It is also known that as swirl strength is increased, the flow will eventually breakdown, resulting in internal flow recirculation and decreased diffuser performance. However, the relationship between the diffuser geometry and its performance at these higher swirl strengths has not been investigated in detail. This link between diffuser geometry, swirl, and performance is investigated using a hybrid RANS-LES based computational model. A series of simulations are performed with the computational model, varying the swirl strength and diffuser half angle ϕ. Overall, there was found to be little relationship between adjusting the diffuser geometry and diffuser performance at high swirl numbers.","tags":["Conical Diffusers","Hybrid Turbulence Models"],"title":"Static Pressure Recovery Effects of Conical Diffusers with Swirling Inlet Flow","type":"publication"},{"authors":null,"categories":null,"content":"Disclaimer I am not a website expert by any means. From my perspective, internet technology is a giant spaghetti monster rivaling the worst code bases imaginable. I find it a miracle it actually works.\nThus, all things below should be interpreted as being to the best of my knowledge.\nSo why do I use cookies? I use Google Analytics on this site so that I can keep count of how many people view the site and how popular specific pages are. Google Analytics does not track your browsing history outside of this website.\nTo do this, Google uses cookies. Via Hugo settings (from which this website is built), I’ve:\nEnabled anonymizing the IP addresses of users Enabled respect of HTTP Do Not Track headers If you have any questions regarding cookies or what they are, see this website for more information.\n","date":1530140400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1586531150,"objectID":"18d05a63a1c8d7ed973cc51838494e41","permalink":"https://www.jameswright.xyz/privacy/","publishdate":"2018-06-28T00:00:00+01:00","relpermalink":"/privacy/","section":"","summary":"Disclaimer I am not a website expert by any means. From my perspective, internet technology is a giant spaghetti monster rivaling the worst code bases imaginable. I find it a miracle it actually works.\nThus, all things below should be interpreted as being to the best of my knowledge.\nSo why do I use cookies? I use Google Analytics on this site so that I can keep count of how many people view the site and how popular specific pages are.","tags":null,"title":"Privacy Policy","type":"page"}]